
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

       <link href="/vision/style.css" rel="stylesheet">
  
</head>
<body>
    <div class="side-menu"><nav class="flex flex-col space-y-4"><div class="menu-group"><h3 class="text-lg font-semibold mb-2">Безнес</h3><div class="flex flex-col space-y-2 pl-4"><div><a href="/vision/RU/business/solenopsys" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Сообщество Solenopsys</a></div><div><a href="/vision/RU/business/robotization" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Фонд Robotization</a></div></div></div><div class="menu-group"><h3 class="text-lg font-semibold mb-2">Фреймворки</h3><div class="flex flex-col space-y-2 pl-4"><div><a href="/vision/RU/frameworks/graphene" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Graphene</a></div><div><a href="/vision/RU/frameworks/organic" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Organic</a></div></div></div><div class="menu-group"><h3 class="text-lg font-semibold mb-2">Технологии</h3><div class="flex flex-col space-y-2 pl-4"><div><a href="/vision/RU/technology/cap" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Протокол CAP</a></div><div><a href="/vision/RU/technology/sdfs" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Файловая система SDFS</a></div></div></div><div class="menu-group"><h3 class="text-lg font-semibold mb-2">Концепты</h3><div class="flex flex-col space-y-2 pl-4"><div><a href="/vision/RU/consepts/srmi" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Инфраструктура SRMI</a></div></div></div><div class="menu-group"><h3 class="text-lg font-semibold mb-2">Документация</h3><div class="flex flex-col space-y-2 pl-4"><div><a href="/vision/RU/docs/reactive" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Converged Reactive</a></div><div><a href="/vision/RU/docs/renderer" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Converged Renderer</a></div><div><a href="/vision/RU/docs/router" class="menu-item text-gray-700 hover:text-gray-900 transition-colors duration-200">Converged Router</a></div></div></div></nav></div> 
    <div class="content">
        <div class="page"><div><h1>Router</h1>
<p>Based on <a href="https://github.com/vobyjs/voby-router">Voby Router</a></p>
<h2>The router for <a href="https://github.com/solenopsys/converged-renderer">Converged-Renderer</a>.</h2>
<p>A router lets you change your view based on the URL in the browser. This allows your "single-page" application to simulate a traditional multipage site. To use Converged Router, you specify components called Routes that depend on the value of the URL (the "path"), and the router handles the mechanism of swapping them in and out.</p>
<p>Converged-Renderer router is a universal router for Converged Renderer - it works whether you're rendering on the client or on the server. It was inspired by and combines paradigms of React Router and the Ember Router. Routes can be defined directly in your app's template using JSX, but you can also pass your route configuration directly as an object. It also supports nested routing, so navigation can change a part of a component, rather than completely replacing it. </p>
<p>Use it freely with suspense, resources, and lazy components. Converged-Renderer router also allows you to define a data function that loads parallel to the routes (<a href="https://epicreact.dev/render-as-you-fetch/">render-as-you-fetch</a>).</p>
</div><div><h2>Getting Started</h2>
</div><div><h3>Set Up the Router</h3>
<pre><code class="language-sh">&gt; npm i  @solenopsys/converged-router
</code></pre>
<p>Install <code> @solenopsys/converged-router</code>, then wrap your root component with the Router component:</p>
<pre><code class="language-jsx">import { render } from  "@solenopsys/converged-renderer";
import { Router } from "@solenopsys/converged-router";
import App from "./App";

render(
  () =&gt; (
    &lt;Router&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  ),
  document.getElementById("app")
);
</code></pre>
<p>This sets up a context so that we can display the routes anywhere in the app.</p>
</div><div><h3>Configure Your Routes</h3>
<p><code> @solenopsys/converged-router</code> allows you to configure your routes using JSX:</p>
<ol>
<li>Use the <code>Routes</code> component to specify where the routes should appear in your app.</li>
</ol>
<pre><code class="language-jsx">import { Routes, Route } from "@solenopsys/converged-router"

export default function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Site with Lots of Pages&lt;/h1&gt;
      &lt;Routes&gt;

      &lt;/Routes&gt;
    &lt;&gt;
  )
}
</code></pre>
<ol start="2">
<li>Add each route using the <code>Route</code> component, specifying a path and an element to render when the user navigates to that path.</li>
</ol>
<pre><code class="language-jsx">import { Routes, Route } from "@solenopsys/converged-router"

import Home from "./pages/Home"
import Users from "./pages/Users"

export default function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Site with Lots of Pages&lt;/h1&gt;
      &lt;Routes&gt;
        &lt;Route path="/users" element={&lt;Users/&gt;} /&gt;
        &lt;Route path="/" element={&lt;Home/&gt;} /&gt;
        &lt;Route path="/about" element={&lt;div&gt;This site was made with Converged-Renderer&lt;/div&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;&gt;
  )
}
</code></pre>
<ol start="3">
<li>Lazy-load route components</li>
</ol>
<p>This way, the <code>Users</code> and <code>Home</code> components will only be loaded if you're navigating to <code>/users</code> or <code>/</code>, respectively.</p>
<pre><code class="language-jsx">import { lazy } from  "@solenopsys/converged-renderer";
import { Routes, Route } from "@solenopsys/converged-router"
const Users = lazy(() =&gt; import("./pages/Home"));
const Home = lazy(() =&gt; import("./pages/Users"));

export default function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Site with Lots of Pages&lt;/h1&gt;
      &lt;Routes&gt;
        &lt;Route path="/users" element={&lt;Users/&gt;} /&gt;
        &lt;Route path="/" element={&lt;Home/&gt;} /&gt;
        &lt;Route path="/about" element={&lt;div&gt;This site was made with Converged-Renderer&lt;/div&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;&gt;
  )
}
</code></pre>
</div><div><h2>Create Links to Your Routes</h2>
<p>Use the <code>A</code> component to create an anchor tag that takes you to a route:</p>
<pre><code class="language-jsx">import { lazy } from  "@solenopsys/converged-renderer";
import { Routes, Route, A } from "@solenopsys/converged-router"
const Users = lazy(() =&gt; import("./pages/Home"));
const Home = lazy(() =&gt; import("./pages/Users"));

export default function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Site with Lots of Pages&lt;/h1&gt;
      &lt;nav&gt;
        &lt;A href="/about"&gt;About&lt;/A&gt;
        &lt;A href="/"&gt;Home&lt;/A&gt;
      &lt;/nav&gt;
      &lt;Routes&gt;
        &lt;Route path="/users" element={&lt;Users/&gt;} /&gt;
        &lt;Route path="/" element={&lt;Home/&gt;} /&gt;
        &lt;Route path="/about" element={&lt;div&gt;This site was made with Converged-Renderer&lt;/div&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;&gt;
  )
}
</code></pre>
<p>The <code>&lt;A&gt;</code> tag also has an <code>active</code> class if its href matches the current location, and <code>inactive</code> otherwise. <strong>Note:</strong> By default matching includes locations that are descendents (eg. href <code>/users</code> matches locations <code>/users</code> and <code>/users/123</code>), use the boolean <code>end</code> prop to prevent matching these. This is particularly useful for links to the root route <code>/</code> which would match everything.</p>
<table>
<thead>
<tr>
<th>prop</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>string</td>
<td>The path of the route to navigate to. This will be resolved relative to the route that the link is in, but you can preface it with <code>/</code> to refer back to the root.</td>
</tr>
<tr>
<td>noScroll</td>
<td>boolean</td>
<td>If true, turn off the default behavior of scrolling to the top of the new page</td>
</tr>
<tr>
<td>replace</td>
<td>boolean</td>
<td>If true, don't add a new entry to the browser history. (By default, the new page will be added to the browser history, so pressing the back button will take you to the previous route.)</td>
</tr>
<tr>
<td>state</td>
<td>unknown</td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState">Push this value</a> to the history stack when navigating</td>
</tr>
<tr>
<td>inactiveClass</td>
<td>string</td>
<td>The class to show when the link is inactive (when the current location doesn't match the link)</td>
</tr>
<tr>
<td>activeClass</td>
<td>string</td>
<td>The class to show when the link is active</td>
</tr>
<tr>
<td>end</td>
<td>boolean</td>
<td>If <code>true</code>, only considers the link to be active when the curent location matches the <code>href</code> exactly; if <code>false</code>, check if the current location <em>starts with</em> <code>href</code></td>
</tr>
</tbody></table>
</div><div><h3>The Navigate Component</h3>
<p><code> @solenopsys/converged-router</code> provides a <code>Navigate</code> component that works similarly to <code>A</code>, but it will <em>immediately</em> navigate to the provided path as soon as the component is rendered. It also uses the <code>href</code> prop, but you have the additional option of passing a function to <code>href</code> that returns a path to navigate to:</p>
<pre><code class="language-jsx">function getPath ({navigate, location}) {
  //navigate is the result of calling useNavigate(); location is the result of calling useLocation(). 
  //You can use those to dynamically determine a path to navigate to
  return "/some-path";
}

//Navigating to /redirect will redirect you to the result of getPath
&lt;Route path="/redirect" element={  &lt;Navigate href={getPath}/&gt;} /&gt;
</code></pre>
</div><div><h2>Dynamic Routes</h2>
<p>If you don't know the path ahead of time, you might want to treat part of the path as a flexible parameter that is passed on to the component. </p>
<pre><code class="language-jsx">import { lazy } from  "@solenopsys/converged-renderer";
import { Routes, Route } from "@solenopsys/converged-router"
const Users = lazy(() =&gt; import("./pages/Home"));
const Home = lazy(() =&gt; import("./pages/Users"));
const Home = lazy(() =&gt; import("./pages/User"));

export default function App() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Site with Lots of Pages&lt;/h1&gt;
      &lt;Routes&gt;
        &lt;Route path="/users" element={&lt;Users/&gt;} /&gt;
        &lt;Route path="/users/:id" element={&lt;User/&gt;} /&gt;
        &lt;Route path="/" element={&lt;Home/&gt;} /&gt;
        &lt;Route path="/about" element={&lt;div&gt;This site was made with Converged-Renderer&lt;/div&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;&gt;
  )
}
</code></pre>
<p>The colon indicates that <code>id</code> can be any string, and as long as the URL fits that pattern, the <code>User</code> component will show.</p>
<p>You can then access that <code>id</code> from within a route component with <code>useParams</code>:</p>
<pre><code class="language-jsx">//async fetching function
import { fetchUser } ...

export default function User () {

  const params = useParams();

  const [userData] = createResource(() =&gt; params.id, fetchUser);

  return &lt;A href={userData.twitter}&gt;{userData.name}&lt;/A&gt;
}
</code></pre>
</div><div><h3>Wildcard Routes</h3>
<p><code>:param</code> lets you match an arbitrary name at that point in the path. You can use <code>*</code> to match any end of the path:</p>
<pre><code class="language-jsx">//Matches any path that begins with foo, including foo/, foo/a/, foo/a/b/c
&lt;Route path='foo/*' element={&lt;Foo/&gt;}/&gt;
</code></pre>
<p>If you want to expose the wild part of the path to the component as a parameter, you can name it:</p>
<pre><code class="language-jsx">&lt;Route path='foo/*any' element={&lt;div&gt;{useParams().any}&lt;/div&gt;}/&gt;
</code></pre>
<p>Note that the wildcard token must be the last part of the path; <code>foo/*any/bar</code> won't create any routes.</p>
</div><div><h2>Data Functions</h2>
<p>In the <a href="#dynamic-routes">above example</a>, the User component is lazy-loaded and then the data is fetched. With route data functions, we can instead start fetching the data parallel to loading the route, so we can use the data as soon as possible.</p>
<p>To do this, create a function that fetches and returns the data using <code>createResource</code>. Then pass that function to the <code>data</code> prop of the <code>Route</code> component. </p>
<pre><code class="language-js">import { lazy } from  "@solenopsys/converged-renderer";
import { Route } from "@solenopsys/converged-router";
import { fetchUser } ... 

const User = lazy(() =&gt; import("/pages/users/[id].js"));

//Data function
function UserData({params, location, navigate, data}) {
  const [user] = createResource(() =&gt; params.id, fetchUser);
  return user;
}

//Pass it in the route definition
&lt;Route path="/users/:id" element={&lt;User /&gt;} data={UserData} /&gt;;
</code></pre>
<p>When the route is loaded, the data function is called, and the result can be accessed by calling <code>useRouteData()</code> in the route component.</p>
<pre><code class="language-jsx">//pages/users/[id].js
import { useRouteData } from ' @solenopsys/converged-router';
export default function User() {
  const user = useRouteData();
  return &lt;h1&gt;{user().name}&lt;/h1&gt;;
}
</code></pre>
<p>As its only argument, the data function is passed an object that you can use to access route information:</p>
<table>
<thead>
<tr>
<th>key</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>params</td>
<td>object</td>
<td>The route parameters (same value as calling <code>useParams()</code> inside the route component)</td>
</tr>
<tr>
<td>location</td>
<td><code>{ pathname, search, hash, query, state, key}</code></td>
<td>An object that you can use to get more information about the path (corresponds to <a href="#uselocation"><code>useLocation()</code></a>)</td>
</tr>
<tr>
<td>navigate</td>
<td><code>(to: string, options?: NavigateOptions) =&gt; void</code></td>
<td>A function that you can call to navigate to a different route instead (corresponds to <a href="#usenavigate"><code>useNavigate()</code></a>)</td>
</tr>
<tr>
<td>data</td>
<td>unknown</td>
<td>The data returned by the <a href="#nested-routes">parent's</a> data function, if any. (Data will pass through any intermediate nesting.)</td>
</tr>
</tbody></table>
<p>A common pattern is to export the data function that corresponds to a route in a dedicated <code>route.data.js</code> file. This way, the data function can be imported without loading anything else.</p>
<pre><code class="language-js">import { lazy } from  "@solenopsys/converged-renderer";
import { Route } from "@solenopsys/converged-router";
import { fetchUser } ... 
import UserData from "./pages/users/[id].data.js";
const User = lazy(() =&gt; import("/pages/users/[id].js"));

// In the Route definition
&lt;Route path="/users/:id" element={&lt;User /&gt;} data={UserData} /&gt;;
</code></pre>
</div><div><h2>Nested Routes</h2>
<p>The following two route definitions have the same result:</p>
<pre><code class="language-jsx">&lt;Route path="/users/:id" element={&lt;User/&gt;} /&gt;
</code></pre>
<pre><code class="language-jsx">&lt;Route path="/users"&gt;
  &lt;Route path="/:id" element={&lt;User/&gt;} /&gt;
&lt;/Route&gt;
</code></pre>
<p><code>/users/:id</code> renders the <code>&lt;User/&gt;</code> component, and <code>/users/</code> is an empty route.</p>
<p>Only leaf Route nodes (innermost <code>Route</code> components) are given a route. If you want to make the parent its own route, you have to specify it separately:</p>
<pre><code class="language-jsx">//This won't work the way you'd expect
&lt;Route path="/users" element={&lt;Users/&gt;}&gt;
  &lt;Route path="/:id" element={&lt;User/&gt;} /&gt;
&lt;/Route&gt;

//This works
&lt;Route path="/users" element={&lt;Users/&gt;} /&gt;
&lt;Route path="/users/:id" element={&lt;User/&gt;} /&gt;

//This also works
&lt;Route path="/users"&gt;
  &lt;Route path="/" element={&lt;Users/&gt;} /&gt;
  &lt;Route path="/:id" element={&lt;User/&gt;} /&gt;
&lt;/Route&gt;
</code></pre>
<p>You can also take advantage of nesting by adding a parent element with an <code>&lt;Outlet/&gt;</code>.</p>
<pre><code class="language-jsx">
import { Outlet } from "@solenopsys/converged-router";

function PageWrapper () {
  return &lt;div&gt;
    &lt;h1&gt; We love our users! &lt;/h1&gt;
    &lt;Outlet/&gt;
    &lt;A href="/"&gt;Back Home&lt;/A&gt;
  &lt;/div&gt;
}

&lt;Route path="/users" element={&lt;PageWrapper/&gt;}&gt;
  &lt;Route path="/" element={&lt;Users/&gt;} /&gt;
  &lt;Route path="/:id" element={&lt;User/&gt;} /&gt;
&lt;/Route&gt;
</code></pre>
<p>The routes are still configured the same, but now the route elements will appear inside the parent element where the <code>&lt;Outlet/&gt;</code> was declared.</p>
<p>You can nest indefinitely - just remember that only leaf nodes will become their own routes. In this example, the only route created is <code>/layer1/layer2</code>, and it appears as three nested divs.</p>
<pre><code class="language-jsx">&lt;Route path='/' element={&lt;div&gt;Onion starts here &lt;Outlet /&gt;&lt;/div&gt;}&gt;
  &lt;Route path='layer1' element={&lt;div&gt;Another layer &lt;Outlet /&gt;&lt;/div&gt;}&gt;
    &lt;Route path='layer2' element={&lt;div&gt;Innermost layer&lt;/div&gt;}&gt;&lt;/Route&gt;
  &lt;/Route&gt;
&lt;/Route&gt;
</code></pre>
<p>If you declare a <code>data</code> function on a parent and a child, the result of the parent's data function will be passed to the child's data function as the <code>data</code> property of the argument, as described in the last section. This works even if it isn't a direct child, because by default every route forwards its parent's data. </p>
</div><div><h2>Config Based Routing</h2>
<p>You don't have to use JSX to set up your routes; you can pass an object directly with <code>useRoutes</code>:</p>
<pre><code class="language-jsx">import { lazy, render } from  "@solenopsys/converged-renderer";
import { Router, useRoutes, A } from "@solenopsys/converged-router";

const routes = [
  {
    path: "/users",
    component: lazy(() =&gt; import("/pages/users.js"))
  },
  {
    path: "/users/:id",
    component: lazy(() =&gt; import("/pages/users/[id].js")),
    children: [
      { path: "/", component: lazy(() =&gt; import("/pages/users/[id]/index.js")) },
      { path: "/settings", component: lazy(() =&gt; import("/pages/users/[id]/settings.js")) },
      { path: "/*all", component: lazy(() =&gt; import("/pages/users/[id]/[...all].js")) }
    ]
  },
  {
    path: "/",
    component: lazy(() =&gt; import("/pages/index.js"))
  },
  {
    path: "/*all",
    component: lazy(() =&gt; import("/pages/[...all].js"))
  }
];

function App() {
  const Routes = useRoutes(routes);
  return (
    &lt;&gt;
      &lt;h1&gt;Awesome Site&lt;/h1&gt;
      &lt;A class="nav" href="/"&gt;
        Home
      &lt;/A&gt;
      &lt;A class="nav" href="/users"&gt;
        Users
      &lt;/A&gt;
      &lt;Routes /&gt;
    &lt;/&gt;
  );
}

render(
  () =&gt; (
    &lt;Router&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  ),
  document.getElementById("app")
);
</code></pre>
</div><div><h2>Router Primitives</h2>
<p>Converged-Renderer Router provides a number of primitives that read off the Router and Route context.</p>
</div><div><h3>useParams</h3>
<p>Retrieves an object containing the route path parameters as defined in the Route.</p>
<pre><code class="language-js">const params = useParams();

// fetch user based on the id path parameter
const [user] = createResource(() =&gt; params.id, fetchUser);
</code></pre>
</div><div><h3>useNavigate</h3>
<p>Retrieves method to do navigation. The method accepts a path to navigate to and an optional object with the following options:</p>
<ul>
<li>resolve (<em>boolean</em>, default <code>true</code>): resolve the path against the current route</li>
<li>replace (<em>boolean</em>, default <code>false</code>): replace the history entry</li>
<li>scroll (<em>boolean</em>, default <code>true</code>): scroll to top after navigation</li>
<li>state (<em>any</em>, default <code>undefined</code>): pass custom state to <code>location.state</code></li>
</ul>
<p><strong>Note:</strong> The state is serialized using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">structured clone algorithm</a> which does not support all object types.</p>
<pre><code class="language-js">const navigate = useNavigate();

if (unauthorized) {
  navigate("/login", { replace: true });
}
</code></pre>
</div><div><h3>useLocation</h3>
<p>Retrieves reactive <code>location</code> object useful for getting things like <code>pathname</code></p>
<pre><code class="language-js">const location = useLocation();

const pathname = useComputed(() =&gt; parsePath(location.pathname));
</code></pre>
</div><div><h3>useSearchParams</h3>
<p>Retrieves a tuple containing a reactive object to read the current location's query parameters and a method to update them. The object is a proxy so you must access properties to subscribe to reactive updates. Note values will be strings and property names will retain their casing.</p>
<p>The setter method accepts an object whose entries will be merged into the current query string. Values <code>''</code>, <code>undefined</code> and <code>null</code> will remove the key from the resulting query string. Updates will behave just like a navigation and the setter accepts the same optional second parameter as <code>navigate</code> and auto-scrolling is disabled by default.</p>
<pre><code class="language-js">const [searchParams, setSearchParams] = useSearchParams();

return (
  &lt;div&gt;
    &lt;span&gt;Page: {searchParams.page}&lt;/span&gt;
    &lt;button onClick={() =&gt; setSearchParams({ page: searchParams.page + 1 })}&gt;Next Page&lt;/button&gt;
  &lt;/div&gt;
);
</code></pre>
</div><div><h3>useRouteData</h3>
<p>Retrieves the return value from the data function.</p>
<blockquote>
<p>In previous versions you could use numbers to access parent data. This is no longer supported. Instead the data functions themselves receive the parent data that you can expose through the specific nested routes data.</p>
</blockquote>
<pre><code class="language-js">const user = useRouteData();

return &lt;h1&gt;{user().name}&lt;/h1&gt;;
</code></pre>
</div><div><h3>useMatch</h3>
<p><code>useMatch</code> takes an accessor that returns the path and creates a Memo that returns match information if the current path matches the provided path. Useful for determining if a given path matches the current route.</p>
<pre><code class="language-js">const match = useMatch(() =&gt; props.href);

return &lt;div classList={{ active: Boolean(match()) }} /&gt;;
</code></pre>
<h3>useRoutes</h3>
<p>Used to define routes via a config object instead of JSX. See <a href="#config-based-routing">Config Based Routing</a>.</p>
</div></div>
    </div>
</body>
</html>
